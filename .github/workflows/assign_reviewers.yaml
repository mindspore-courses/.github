name: Auto Assign Reviewers

on:
  pull_request_target:
    types: [opened, synchronize]

jobs:
  get-reviewers:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Generate GitHub App token
        id: generate-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Checkout org .github repo (for CODEOWNERS)
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/.github
          path: .github-org
          ref: master
          token: ${{ steps.generate-token.outputs.token }}

      - name: Debug .github-org directory
        run: |
          echo "=== .github-org directory structure ==="
          ls -la .github-org/
          ls -la .github-org/.github/  # Êü•ÁúãÊòØÂê¶ÊúâCODEOWNERS

      - name: Get modified files in PR
        id: modified-files
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.generate-token.outputs.token }}
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            const filePaths = files.map(f => f.filename.replace(/^\//, '')).join(';');
            console.log('Semicolon-delimited files:', filePaths);
            return filePaths;

      - name: Parse .github CODEOWNERS to find reviewers
        id: codeowners-parser
        run: |

          set -euo pipefail
          trap 'echo "‚ùå Error occurred at line $LINENO: $BASH_COMMAND" >&2' ERR

          # Get basic info
          CURRENT_REPO=$(basename "${{ github.repository }}")
          PR_AUTHOR="${{ github.actor }}"
          CODEOWNERS_PATH=".github-org/.github/CODEOWNERS"

          echo "=== Basic Info ==="
          echo "Current repository: $CURRENT_REPO"
          echo "PR author: $PR_AUTHOR"
          echo "Org CODEOWNERS path: $CODEOWNERS_PATH"

          # Check if CODEOWNERS exists
          if [ ! -f "$CODEOWNERS_PATH" ]; then
            echo "Error: Org CODEOWNERS file not found in .github repo"
            exit 1
          else
            echo "‚úÖ CODEOWNERS file found!"
          fi

          # Extract and normalize all rules
          all_rules=$(grep -v '^#\|^$' "$CODEOWNERS_PATH")

          # Extract repo-specific rules
          repo_specific_rules=$(echo "$all_rules" | grep -E "^/$CURRENT_REPO/" || true)
          # Extract global rules
          org_root_rules=$(echo "$all_rules" | grep -E '^/\.[[:space:]]+@' || true)

          # Extract orgnization owners
          org_owners=$(echo "$org_root_rules" | sed -E 's|^/\.[[:space:]]+@?||; s/[[:space:]]+$//' | tr ' ' '\n' | sed 's/^@//' | sort -u)
          if [ -z "$org_owners" ]; then
            echo "Error: No org fallback owners found in CODEOWNERS (expect: /. @org-owner1 [@org-owner2 ...])"
            exit 1
          fi
          echo -e "\n=== Org Fallback Owners (from CODEOWNERS /. rule) ==="
          echo "$org_owners" | while read -r owner; do
            echo " - $owner"
          done
          org_owner_count=$(echo "$org_owners" | wc -l | tr -d '[:space:]')
          echo "Total org fallback owners extracted: $org_owner_count"

          # Get semicolon-delimited modified files from PR and split into array
          modified_files_str=${{ steps.modified-files.outputs.result }}
          IFS=';' read -ra modified_files <<< "$modified_files_str"
          [ ${#modified_files[@]} -eq 0 ] && { echo "reviewers=" >> "$GITHUB_OUTPUT"; exit 0; }

          # Verify split worked
          echo "Split modified files into ${#modified_files[@]} files:"
          for file in "${modified_files[@]}"; do
            echo " - $file"
          done

          # ======================
          # Step 1: Prioritize Repository-Specific Owners
          # ======================

          declare -A repo_owners=()

          if [ -n "$repo_specific_rules" ]; then
            echo -e "\n=== Processing Repository-Specific Rules ==="
            # Directly extract owners from top-level repo rules (e.g., /repo-a/ @user1 @user2)
            repo_owners_str=$(echo "$repo_specific_rules" |
              sed -E "s|^/$CURRENT_REPO/[[:space:]]*||" |
              tr -s ' ' '\n' |
              grep -E '^@' |
              sed 's/^@//')

            for owner in $repo_owners_str; do
              if [ -n "$owner" ] && [ "$owner" != "0" ]; then
                repo_owners["$owner"]=1
                echo "Found repo owner: $owner"
              fi
            done
          else
            echo -e "\n=== No Repository-Specific Rules Found for $CURRENT_REPO ==="
          fi

          # ======================
          # Step 2: Build Final Reviewer List (Exclude PR Author)
          # ======================
          declare -A final_reviewers=()
          has_valid_repo_owners=false

          # Check for valid owners
          for owner in "${!repo_owners[@]}"; do
            if [ -n "$owner" ] && [ "$owner" != "0" ]; then
              has_valid_repo_owners=true
              break
            fi
          done

          # Process valid repo owners
          if [ "$has_valid_repo_owners" = true ]; then
            echo -e "\n=== Repository-Specific Owners (After Exclusion) ==="
            for owner in "${!repo_owners[@]}"; do
              if [ "$owner" != "$PR_AUTHOR" ]; then
                final_reviewers["$owner"]=1
                echo "Added repo owner: $owner (not PR author)"
              else
                echo "Skipped repo owner: $owner (matches PR author)"
              fi
            done
          fi

          # If no valid repo owners, add org fallback owners (exclude PR author)
          if [ ${#final_reviewers[@]} -eq 0 ]; then
            echo -e "\n=== No Valid Repo Owners, Using Org Fallback ==="
            for org_owner in $org_owners; do
              clean_owner=$(echo "$org_owner" | sed 's/^@//')  # Handle residual @ symbols if present
              if [ -n "$clean_owner" ] && [ "$clean_owner" != "0" ] && [ "$clean_owner" != "$PR_AUTHOR" ]; then
                final_reviewers["$clean_owner"]=1
                echo "Added org owner: $clean_owner"
              else
                echo "Skipped org owner: $clean_owner (matches PR author)"
              fi
            done
          fi

          # ======================
          # Step 3: Output Final Result (Validation + Formatting)
          # ======================
          if [ ${#final_reviewers[@]} -eq 0 ]; then
            echo "Error: No valid reviewers found (all are PR author)"
            exit 1
          fi

          # Convert to comma-separated string
          unique_reviewers=$(echo "${!final_reviewers[@]}" | tr ' ' ',' | sed 's/^,//;s/,$//')
          echo "reviewers=$unique_reviewers" >> "$GITHUB_OUTPUT"
          echo -e "\n=== Final Reviewers ==="
          echo "$unique_reviewers"


      - name: Assign reviewers and comment
        if: >
          steps.codeowners-parser.outputs.reviewers != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.generate-token.outputs.token }}
          script: |
            const targetReviewers = '${{ steps.codeowners-parser.outputs.reviewers }}'.split(',').filter(r => r.trim());
            const prNumber = context.issue.number;
            const repoOwner = context.repo.owner;
            const repoName = context.repo.repo;

            core.info(`=== [Debug] Assign Reviewers Start ===`);
            core.info(`PR Number: ${prNumber}`);
            core.info(`Repo Owner: ${repoOwner}`);
            core.info(`Repo Name: ${repoName}`);
            core.info(`Original Reviewers Input: ${{ steps.codeowners-parser.outputs.reviewers }}`);
            core.info(`Filtered Valid Reviewers: ${targetReviewers.join(', ')}`);
            core.info(`=======================================`);

            if (targetReviewers.length === 0) {
              core.info("No valid reviewers to process, skipping.");
              return;
            }

            const prNumber = context.issue.number;
            const repoInfo = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            };

            // Track execution status of each sub-step for failure localization
            let fetchCurrentReviewersSuccess = false;
            let assignMissingReviewersSuccess = false;
            let addCommentSuccess = false;

            try {
              // 1. Fetch currently assigned reviewers
              core.info(`üîß Step 1/3: Fetching currently assigned reviewers for PR #${prNumber}`);
              const { data: currentReviews } = await github.rest.pulls.listRequestedReviewers(repoInfo);
              const currentReviewers = currentReviews.users.map(user => user.login);
              core.info(`Current assigned reviewers: ${currentReviewers.join(', ')}`);
              core.info(`‚úÖ Step 1/3 Success: Current assigned reviewers: ${currentReviewers.length > 0 ? currentReviewers.join(', ') : 'None'}`);
              fetchCurrentReviewersSuccess = true;

              // 2. Assign only missing reviewers
              core.info(`üîß Step 2/3: Checking for missing reviewers`);
              const missingReviewers = targetReviewers.filter(r => !currentReviewers.includes(r));
              if (missingReviewers.length > 0) {
                await github.rest.pulls.requestReviewers({
                  ...repoInfo,
                  reviewers: missingReviewers
                });
                core.info(`‚úÖ Step 2/3 Success: Assigned missing reviewers: ${missingReviewers.join(', ')}`);
                assignMissingReviewersSuccess = true;
              } else {
                core.info(`‚úÖ Step 2/3 Success: All target reviewers are already assigned.`);
                assignMissingReviewersSuccess = true;
              }

              // 3. Add comment mentioning all reviewers
              core.info(`üîß Step 3/3: Adding auto-assignment comment to PR #${prNumber}`);
              const commentReviewers = targetReviewers.map(r => `@${r}`).join(' ');
              await github.rest.issues.createComment({
                ...repoInfo,
                body: `The following reviewers have been auto-assigned: ${commentReviewers}.
                Please proceed with the review at your earliest convenience. You may also request additional reviewers if appropriate. Thank you.`
              });
              core.info(`‚úÖ Step 3/3 Success: Comment added successfully`);
              addCommentSuccess = true;

            } catch (error) {
              // Precisely locate failed step and output full error details
              core.error(`\n‚ùå Critical Error: One of the steps failed!`);
              core.error(`Failed Step Details:`);
              core.error(`- Step 1 (Fetch Current Reviewers): ${fetchCurrentReviewersSuccess ? '‚úÖ Success' : '‚ùå Failed'}`);
              core.error(`- Step 2 (Assign Missing Reviewers): ${assignMissingReviewersSuccess ? '‚úÖ Success' : '‚ùå Failed'}`);
              core.error(`- Step 3 (Add Comment): ${addCommentSuccess ? '‚úÖ Success' : '‚ùå Failed'}`);
              core.error(`\nFull Error Message: ${error.message}`);
              core.error(`Error Stack Trace: ${error.stack}`);
              core.error(`Error Response (if API): ${JSON.stringify(error.response?.data || 'No API response', null, 2)}`);
              core.warning("\n‚ö†Ô∏è Reviewer processing failed, but workflow will continue.");
            }

            core.info(`\n=== [Debug] Assign Reviewers End ===`);
